数据库事务定义：一致性、隔离性
事务（Transaction）的特性ACID
事务（Transaction）的隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable：实现原理：共享锁、独占锁、行级锁、表级锁  
事务隔离解决问题：脏读、不可重复读、幻读
怎么实现ACID：实现ACID的核心技术是并发控制和日志技术
并发控制：2PL、OCC、MVCC：保证并发操作的正确性
日志：Redo/Undo,WAL协议：保证故障场景下可恢复

DB深度分页：覆盖索引、主键索引+join、倒序排列、缓存若干页、业务不允许查太多页  
- [](#)
- [](#)
- [](#)
- [](#)
- [](#)



---------------------------------------------------------------------------------------------------------------------

数据库事务：  
定义：一致性、隔离性  
特性：ACID  
事务隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable：实现原理：共享锁、独占锁、行级锁、表级锁  
1、实现原理是，读数据时候不加锁，写数据时候加行级别的共享锁，提交时释放锁。  
2、实现原理是，事务读取数据（读到数据的时候）加行级共享锁，读完释放；事务写数据时候（写操作发生的瞬间）加行级独占锁，事务结束释放。【读到数据的时候才加锁】  
3、和读提交数据不同的是，事务读取数据在读操作开始的瞬间就加上行级共享锁，而且在事务结束的时候才释放。【未读就开始加锁】  
4、实现原理是，在读操作时，加表级共享锁，事务结束时释放；写操作时候，加表级独占锁，事务结束时释放。【前面都是行级锁，串行化是表级锁】  
事务隔离解决问题：脏读、不可重复读、幻读  
怎么实现ACID：并发控制、日志  
并发控制：2PL、OCC、MVCC  
日志：redo/undo、WAL  
  
DB深度分页：覆盖索引、主键索引+join、倒序排列、缓存若干页、业务不允许查太多页  


1、什么是事务（Transaction）
根据维基百科的定义，一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：1）为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法；2）当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。简单来讲，事务的作用至少有两个：保证数据一致性，以及对数据进行隔离。

2、事务（Transaction）的特性
ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

3、事务（Transaction）的隔离级别
SQL标准定义了4种事务隔离级别：读未提交，读已提交，可重复读，串行化
分别解决了：脏读、不可重复读、幻读
脏读：读取的是未提交的数据
不可重复读：两次读取的数据不一致
幻读（虚读）：读取的记录数量不一致，增多或者减少

数据库事务的隔离级别有4个，由低到高依次为
Read uncommitted(未授权读取、读未提交)、可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
Read committed（授权读取、读提交）、可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
Repeatable read（可重复读取）、可能出现幻读
Serializable（序列化）

数据库事务隔离级别和锁的实现方式
https://blog.csdn.net/yangtianyu1218/article/details/51543634


4、怎么实现ACID
http://tech.it168.com/a2016/0905/2900/000002900122.shtml
实现ACID的核心技术是并发控制和日志技术
并发控制：2PL、OCC、MVCC：保证并发操作的正确性
日志：Redo log/Undo log,WAL协议：保证故障场景下可恢复


https://www.zhihu.com/question/60278698
最简单的并发控制算法是2PL（2 Phase Locking），分为两阶段：
1）获得锁阶段；
2）释放锁阶段。
一般2PL被称为是悲观并发控制。

乐观并发控制OCC（ Optimistic Concurrency Control）。OCC假设事务会成功，开始事务时该读读，该写写，不加锁。只有到提交时做一下验证，验证这个事务是不是能够成功提交。 OCC分为三阶段：
1）Read Phase, 对于读，放到Read Set，对于写，把写记到临时副本，放到Write Set。因为写是写到临时区的，属于未提交结果，其它事务读不到（这点是和MVCC的重要区别）；
2）Validation Phase，重扫Read Set，Write Set，检验数据是否满足Isolation Level，如果满足则Commit，否则Abort；
3）WritePhase，或者叫做Commit Phase，把临时副本区的数据更新到数据库中，完成事务提交。

MVCC（Multiversion Concurrency Control）是另一种并发控制算法。MVCC为每条记录维护多个快照（Snapshot），通过起止两个时间戳（Begin Timestamp / End Timestamp）维护副本的可见性。
读写进行的不同操作如下：
Update，创建一个新的版本（Version）；
Delete，更新End Timestamp。
Read，通过起止时间戳判定记录是否对当前事务可见（OCC读不到未提交的记录，所以不需要做这个判断）。


innodb通过undo log和redo log来实现。事务中，每当执行一条SQL语句对数据产生了影响，就会记录下来与之相反的操作到undo log(撤销日志）中，例如，更新会记录之前的状态，删除会形成insert，添加会形成delete，一旦事务被回滚，则执行undo log中记录的操作，来完成恢复到之前的状态。这里是个 逻辑恢复哦！同时，每当执行一条事务中的SQL，会将操作记录到redo log中，此时事务一旦被提交，就将该redolog中的操作，持久化到磁盘上，数据就持久的记录下来了（ACID的D）。


WAL(Write Ahead Log)协议解析
Write Ahead Log Protocol
　　1、事务所引起的所有改动都要记录在日志中，在事务提交完成之前，所有的这些记录必须被写入硬盘；
　　2、一个数据库的缓冲页直到被记入日志后才能发生修改。直到缓冲页对应的日志被写入磁盘之后，该缓冲页才会存入磁盘；
　　3、当缓冲页被修改和日志被更新的时候，在也上必须加上互斥锁，以保证改动被记录到日志中的顺序与它发生的顺序是一致的。
　　以上规则的结果：
　　1、如果一条日志记录未被存入硬盘，则它可以被忽略，因为该日志中包含的改动一定属于未提交的事务。此外，这样的日志不能反映已持久化在数据库中的改动；
　　2、日志记录按顺序记录系统的改动。加锁协议（latch protocol）保证如果有对于同一页改动的两条日志记录，则两条记录的顺序反映对页发生改变的顺序。


https://blog.csdn.net/libo222/article/details/52469547
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC

数据库的原子性和一致性的实现：
https://www.zhihu.com/question/30272728
为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制

为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。

原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。
为了保证并发情况下的一致性，引入了隔离性，实现隔离性原则上无非是两种类型的锁：


Pessimistic locking（悲观锁） 与 Optimistic locking（乐观锁）

一种是悲观锁，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽可能提高性能，发明了各种粒度（数据库级/表级/行级……）/各种性质（共享锁/排他锁/共享意向锁/排他意向锁/共享排他意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测等一系列的技术。

一种是乐观锁，即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志UNDO的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。

这两种锁在Java和MySQL分别是怎么实现的？（Java乐观锁通过CAS实现，悲观锁通过synchronize实现。mysql乐观锁通过MVCC，也就是版本实现，悲观锁可以通过select... for update加上排它锁）



原子性：一个事务内的所有SQL操作是一个整体。都执行成功才算整个事务成功。如果某个失败，则必须要会退到事务执行之前的状态，执行成功的SQL需要被撤销。innodb通过undo log和redo log来实现。事务中，每当执行一条SQL语句对数据产生了影响，就会记录下来与之相反的操作到undo log(撤销日志）中，例如，更新会记录之前的状态，删除会形成insert，添加会形成delete，一旦事务被回滚，则执行undo log中记录的操作，来完成恢复到之前的状态。这里是个 逻辑恢复哦！同时，每当执行一条事务中的SQL，会将操作记录到redo log中，此时事务一旦被提交，就将该redolog中的操作，持久化到磁盘上，数据就持久的记录下来了（ACID的D）。
PS：还有，undolog才是原子性的关键。提供redolog，应该主要目的是提升磁盘的IO开销吧，如果直接写入磁盘，IO开销，会很大。如果先将操作记录到redolog中，可以顺序的记录，批量的记录，再一起同步到磁盘上，速度会比直接写磁盘快些。 mysql在生成redolog时，会使用 innodb log buffer，先缓冲到内存中，再同步到redolog上。速度会更快另外关于，一致性，应该是个整体概念，保证所有的mysql对象（数据，索引，约束，日志，用户）在事务执行前后都具有完整的特性，应该是mysql所有的功能都为此服务吧



https://blog.csdn.net/ylforever/article/details/51048945
Two-phase locking(二阶段锁)
为确保一个事务完全隔离，最简单方法是在事务开始时申请锁，在事务结束时释放锁。这意味着，事务必须等待申请完所有需要的锁才开始运行，在执行过程中完全占用锁，结束时才统一释放。这种方案逻辑上没问题，但是会耗费很多时间在等待锁资源上。
一种更快一些的方案是Two-Phase Locking Protocol(在DB2和SQL Server中使用)。在这种方案中，一个事务被分解为两个阶段。
1、在growing phase（发展阶段），事务可以申请锁，不能释放锁。
2、在shrinking phase(收缩阶段)，事务可以释放锁(已经加锁处理过的数据，且不会再处理)，不能申请锁。



---------------------------------------------------------------------------------------------------------------------  
 
数据库事物隔离级别：四种  
http://blog.csdn.net/gaopu12345/article/details/50868501  
http://blog.csdn.net/tolcf/article/details/49283575  
  
MySQL的默认隔离级别就是Repeatable read。  
MySQL 默认的是：可重复读（Repeatable read）
  
数据库事务的隔离级别有4个，由低到高依次为  
Read uncommitted(未授权读取、读未提交)、可能出现脏读。也就是说事务B读取到了事务A未提交的数据。  
Read committed（授权读取、读提交）、可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。  
Repeatable read（可重复读取）、可能出现幻读  
Serializable（序列化）  
  
√: 可能出现    ×: 不会出现  
 						脏读	不可重复读	幻读  
Read uncommitted		√				√				√  
Read committed			×				√				√  
Repeatable read			×				×				√  
Serializable				×				×				×  
  
Read uncommitted(未授权读取、读未提交)：  
如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。  
避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。  
Read committed（授权读取、读提交）：  
读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。  
该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。  
Repeatable read（可重复读取）：  
读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。  
避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。  
  
Serializable（序列化）：  
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。  
序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。  
  
  
（零）没有并发控制  
存在的问题：更新遗失。   
解决办法就是下面的“可读取未确认”。  
  
（一）可读取未确认（Read uncommitted）：  
写事务阻止其他写事务，避免了更新遗失。但是没有阻止其他读事务。 读事务不会阻止其他任何事务。   
存在的问题：脏读。即读取到不正确的数据，因为另一个事务可能还没提交最终数据，这个读事务就读取了中途的数据，这个数据可能是不正确的。   
解决办法就是下面的“可读取确认”。  
  
（二）可读取确认（Read committed）：  
写事务会阻止其他读写事务。读事务不会阻止其他任何事务。   
存在的问题：不可重复读。即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务。   
解决办法就是下面的“可重复读”。  
  
（三）可重复读（Repeatable read）：  
读事务会阻止其他写事务，但是不会阻止其他读事务。 写事务会阻止其他读写事务  
存在的问题：幻读。可重复读阻止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。   
解决办法就是下面的“串行化”。  
  
（四）可串行化（Serializable）：  
读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫串行化。 




---------------------------------------------------------------------------------------------------------------------  



