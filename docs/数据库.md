1、数据库分页重复和分页实现
使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据
Oracle分页查询的三种方法
2、数据库深度分页优化

3、分库分表如何做到永不迁移数据和避免热点

4、

5、

6、







---------------------------------------------------------------------------------------------------------------------
数据库分页重复和分页实现


数据库分页重复
使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据

业务方：接受数据在偶尔情况下能重复的现象
客户端：去重也会有问题，滚动展示的可以使用去重，但是数据量大的话也是不可行的，或者保留临近固定页数的数据去重
服务端：动态的数据搞成静态，查询一定时间段的固定数据，或者 根据某个字段排序采用顺序分页 或者 服务端分页接口参数新增上一页最后一条数据id参数lastId，使用RowID排序然后进行分页


https://blog.csdn.net/jueblog/article/details/9769601
https://blog.51cto.com/ddkangfu/1425797
Oracle分页查询的三种方法
1、采用伪列 rownum
2、运用分析函数：BETWEEN 10 AND 20
3、运用minus方法：


效率较低：WHERE table_alias.rowno <= 20 AND table_alias.rowno >= 10;
嵌套查询的效率比第二个高得多：嵌套查询相当于查询20条去掉前10条，这种相当于查询全部然后再过滤，所以嵌套查询深度分页时候也会很慢

这是由于CBO优化模式下，Oracle可以将外层的查询条件推到内层查询中，以提高内层查询的执行效率。对于第一个查询语句，第二层的查询条件WHERE ROWNUM <= 40就可以被Oracle推入到内层查询中，这样Oracle查询的结果一旦超过了ROWNUM限制条件，就终止查询将结果返回了。

而第二个查询语句，由于查询条件BETWEEN 21 AND 40是存在于查询的第三层，而Oracle无法将第三层的查询条件推到最内层（即使推到最内层也没有意义，因为最内层查询不知道RN代表什么）。因此，对于第二个查询语句，Oracle最内层返回给中间层的是所有满足条件的数据，而中间层返回给最外层的也是所有数据。数据的过滤在最外层完成，显然这个效率要比第一个查询低得多。



---------------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/li772030428/article/details/52839987
https://blog.csdn.net/bestcleaner/article/details/52993468
https://blog.csdn.net/yongshuai185/article/details/55506210



https://blog.csdn.net/ldTrueLove/article/details/52921961
数据库深度分页优化：
limit 及翻页优化
limit offset,N,  当offset非常大时, 效率极低,原因是mysql并不是跳过offset行,然后单取N行,而是取offset+N行,返回放弃前offset行,返回N行.效率较低,当offset越大时,效率越低


1、利用表的覆盖索引来加速分页查询，查询的都是索引中的字段，直接从索引中返回
2、非要物理删除,还要用offset精确查询,还不限制用户分页,怎么办?先使用主键索引查出记录，再用in或者JOIN去查询具体的数据
	分析: 优化思路是 不查,少查,查索引,少取.
	我们现在必须要查,则只查索引,不查数据,得到id.
	再用id去查具体条目.  这种技巧就是延迟索引.
3、倒排序从后面取出对应的记录
4、多缓存几页，每次查询先返回缓存，再查询后面未用到的放进缓存
5、不允许分页太多，比如百度最多70多页







---------------------------------------------------------------------------------------------------------------------


www.toutiao.com/i6677459303055491597

分库分表如何做到永不迁移数据和避免热点？


分库分表：垂直拆分、水平拆分
分库分表方案中有常用的方案：hash取模和range范围方案

hash取模方案：没有热点问题，但扩容迁移数据痛苦
range方案：不需要迁移数据，但有热点问题。range方案也就是以范围进行拆分数据。


两者结合：分组，每个组有不同的数据库，每个库有不同的表
首先用range方案让数据落地到一个范围里面。这样以后id再变大，那以前的数据是不需要迁移的。
然后在同一个分组中，再使用hash表的方式分散到不同的表，因为同一个分组中每个库中的表数量是不同的，因为主机节点的配置，存储是不同的，表数量也不同，所以hash的时候按照表hash，而不是数据库

group表：保存group名称，存储的数据范围起始值
DB表：存储数据库名称，所属group、表的数量或者hash value
table表：表名字，所属DB等
这三张表的信息可以在节点启动的时候，加载到节点的JVM本地缓存中，变化时，可以使用用zookeeper，也可以使用分布式配置改变缓存数据



---------------------------------------------------------------------------------------------------------------------




