- [](#)
- [](#)
- [](#)
- [](#)


1、数据库分页重复和分页实现
使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据
Oracle分页查询的三种方法

2、数据库深度分页优化

3、分库分表如何做到永不迁移数据和避免热点

4、什么是分库分表
  为什么要分库分表
  常见的分库分表手段
  分库分表之后带来的挑战
  数据库分布式事务解决：JTA的XA协议、二阶段提交（2PC、3PC）、柔性事务、最终一致性事务（消息）
  spring事务(Transaction)的七种事务传播行为及五种隔离级别

5、哪些因素会导致慢查询.md


6、执行数据库脚本--注意里面的delete、drop、update

select *与select 所有字段的查询效率比较



一条简单的更新语句，MySQL是如何加锁的？


---------------------------------------------------------------------------------------------------------------------
数据库分页重复和分页实现


数据库分页重复
使用分页SQL的时候，数据如果是动态变化的，就会导致分页查询到重复数据

业务方：接受数据在偶尔情况下能重复的现象
客户端：去重也会有问题，滚动展示的可以使用去重，但是数据量大的话也是不可行的，或者保留临近固定页数的数据去重
服务端：动态的数据搞成静态，查询一定时间段的固定数据，或者 根据某个字段排序采用顺序分页 或者 服务端分页接口参数新增上一页最后一条数据id参数lastId，使用RowID排序然后进行分页


https://blog.csdn.net/jueblog/article/details/9769601
https://blog.51cto.com/ddkangfu/1425797
Oracle分页查询的三种方法
1、采用伪列 rownum
2、运用分析函数：BETWEEN 10 AND 20
3、运用minus方法：


效率较低：WHERE table_alias.rowno <= 20 AND table_alias.rowno >= 10;
嵌套查询的效率比第二个高得多：嵌套查询相当于查询20条去掉前10条，这种相当于查询全部然后再过滤，所以嵌套查询深度分页时候也会很慢

这是由于CBO优化模式下，Oracle可以将外层的查询条件推到内层查询中，以提高内层查询的执行效率。对于第一个查询语句，第二层的查询条件WHERE ROWNUM <= 40就可以被Oracle推入到内层查询中，这样Oracle查询的结果一旦超过了ROWNUM限制条件，就终止查询将结果返回了。

而第二个查询语句，由于查询条件BETWEEN 21 AND 40是存在于查询的第三层，而Oracle无法将第三层的查询条件推到最内层（即使推到最内层也没有意义，因为最内层查询不知道RN代表什么）。因此，对于第二个查询语句，Oracle最内层返回给中间层的是所有满足条件的数据，而中间层返回给最外层的也是所有数据。数据的过滤在最外层完成，显然这个效率要比第一个查询低得多。



---------------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/li772030428/article/details/52839987
https://blog.csdn.net/bestcleaner/article/details/52993468
https://blog.csdn.net/yongshuai185/article/details/55506210



https://blog.csdn.net/ldTrueLove/article/details/52921961
数据库深度分页优化：
limit 及翻页优化
limit offset,N,  当offset非常大时, 效率极低,原因是mysql并不是跳过offset行,然后单取N行,而是取offset+N行,返回放弃前offset行,返回N行.效率较低,当offset越大时,效率越低


1、利用表的覆盖索引来加速分页查询，查询的都是索引中的字段，直接从索引中返回
2、非要物理删除,还要用offset精确查询,还不限制用户分页,怎么办?先使用主键索引查出记录，再用in或者JOIN去查询具体的数据
	分析: 优化思路是 不查,少查,查索引,少取.
	我们现在必须要查,则只查索引,不查数据,得到id.
	再用id去查具体条目.  这种技巧就是延迟索引.
3、倒排序从后面取出对应的记录
4、多缓存几页，每次查询先返回缓存，再查询后面未用到的放进缓存
5、不允许分页太多，比如百度最多70多页




---------------------------------------------------------------------------------------------------------------------


www.toutiao.com/i6677459303055491597

分库分表如何做到永不迁移数据和避免热点？


分库分表：垂直拆分、水平拆分
分库分表方案中有常用的方案：hash取模和range范围方案

hash取模方案：没有热点问题，但扩容迁移数据痛苦
range方案：不需要迁移数据，但有热点问题。range方案也就是以范围进行拆分数据。


两者结合：分组，每个组有不同的数据库，每个库有不同的表
首先用range方案让数据落地到一个范围里面。这样以后id再变大，那以前的数据是不需要迁移的。
然后在同一个分组中，再使用hash表的方式分散到不同的表，因为同一个分组中每个库中的表数量是不同的，因为主机节点的配置，存储是不同的，表数量也不同，所以hash的时候按照表hash，而不是数据库

group表：保存group名称，存储的数据范围起始值
DB表：存储数据库名称，所属group、表的数量或者hash value
table表：表名字，所属DB等
这三张表的信息可以在节点启动的时候，加载到节点的JVM本地缓存中，变化时，可以使用用zookeeper，也可以使用分布式配置改变缓存数据



---------------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/KingCat666/article/details/78324678



1、什么是分库分表
2、为什么要分库分表
3、常见的分库分表手段
4、分库分表之后带来的挑战
5、jdbc和proxy方式的对比


分库分表原因：
读写分离，加快读取和更新速度，减小单表的数据量，减少表锁定的冲突
突破单节点数据库服务器的 I/O 能力限制
解决数据库扩展性问题
数据安全



分库分表策略：
分库分表：垂直拆分、水平拆分
分库分表方案中有常用的方案：hash取模和range范围方案



分库分表存在的问题：
1、事务问题
2、跨库跨表的join问题，跨库跨表的查询
3、额外的数据管理负担和数据运算压力，跨库跨表的排序等计算
  


解决：
使用类似JTA提供的分布式事物机制
数据库分布式事务：二阶段提交（2PC、3PC）、柔性事务、最终一致性事务（消息）


实现XA协议， X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分
二阶提交协议和三阶提交协议就是根据这一思想衍生出来的

Java事务的类型有三种：JDBC事务、JTA(Java Transaction API)事务、容器事务
要想使用用 JTA 事务，那么就需要有一个实现 javax.sql.XADataSource 、 javax.sql.XAConnection 和 javax.sql.XAResource 接口的 JDBC 驱动程序。



传统单点数据库事务:ACID，
老的方式分布式数据库：2PC、3PC
一致性算法：分布式CAP、BASE模型、柔性事务（补偿事务（TCC）（TCC编程（Try、Confirm、Cancel）））

刚性事务：XA分布式协议:2PC、3PC、
柔性事务：BASE模型、TCC、

分布式系统算法：Paxos、Raft、ZAB
两军问题与拜占庭将军问题

2PC/3PC用于保证多个数据分片上事务的原子性
Paxos协议用于保证同一个数据分片在多个副本的一致性





数据库分布式事务：二阶段提交（2PC、3PC）、柔性事务、最终一致性事务（消息）
https://juejin.im/post/5b5a0bf9f265da0f6523913b

https://www.hollischuang.com/archives/1658
http://www.hollischuang.com/archives/681

https://segmentfault.com/a/1190000012762869


https://blog.csdn.net/baidu_37107022/article/details/75578140
spring事务(Transaction)的七种事务传播行为及五种隔离级别

spring七个事务传播属性：
1.PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
2.PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。
3.PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。
4.PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。
5.PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
6.PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。
7.PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。

备注：常用的两个事务传播属性是1和4，即PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW


五个隔离级别：
ISOLATION_DEFAULT 
这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.

另外四个与JDBC的隔离级别相对应；

ISOLATION_READ_UNCOMMITTED 
这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。 
这种隔离级别会产生脏读，不可重复读和幻像读。

ISOLATION_READ_COMMITTED 
保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 
这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

ISOLATION_REPEATABLE_READ 
这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 
它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。

ISOLATION_SERIALIZABLE 
这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 
除了防止脏读，不可重复读外，还避免了幻像读。


关键词： 
1)幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录； 
2)不可重复读取：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录； 
3)脏读：事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。

脏读：指一个事务读取了一个未提交事务的数据
不可重复读：在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.
虚读(幻读)：在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)



---------------------------------------------------------------------------------------------------------------------



select *与select 所有字段的查询效率比较  
结论：两者差别几乎可忽略。所以查询所有字段（或者大多数字段）的时候，大可select *来操作。如果某些不需要的字段数据量特别大，还是写清楚字段比较好，因为这样可以减少网络传输。  
  
（1）SELECT *，需要数据库先 Query Table Metadata For Columns，一定程度上为数据库增加了负担。   
但是实际上，两者效率差别不大。  
（2）考虑到今后的扩展性。   
因为程序里面你需要使用到的列毕竟是确定的， SELECT * 只是减少了一句 SQL String 的长度，并不能减少其他地方的代码。  
综上：除平时练习使用，其他情况都不推荐使用 SELECT * FROM xxx  
  
https://blog.csdn.net/xusheng__zhang/article/details/78949107  
https://blog.csdn.net/LoveLion/article/details/8462814  
http://database.51cto.com/art/200904/118526.htm  
https://juejin.im/entry/5adfef105188256712782f68  
  
https://blog.csdn.net/qingsong3333/article/details/77170831  
数据库优化：https://blog.csdn.net/baidu_37107022/article/details/77460464  
  
  
如何设计一个高并发的系统  
1) 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引优化  
2) 使用缓存、尽量减少数据库IO  
3) 分布式数据库、分布式缓存  
4) 服务器的负载均衡  
  



---------------------------------------------------------------------------------------------------------------------



一条简单的更新语句，MySQL是如何加锁的？


https://blog.51cto.com/14230003/2457784




---------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------



