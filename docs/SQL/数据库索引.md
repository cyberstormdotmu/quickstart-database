数据库优化：  
1) SQL语句及索引的优化  
2) 数据库表结构的优化  
数据库架构扩展：主从复制与读写分离、增加缓存、分库、分表、分区，开启慢查询日志，  
3) 系统配置的优化  
4) 硬件优化 

SQL优化
什么样的sql不走索引：where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等 
检查SQL是否使用了索引：用explain 来执行检验sql     
 mysql:key列显示MySQL实际决定使用的键（索引）
SQL语句优化：避免全表扫描  
MySQL行级锁、表级锁、页级锁的优化

索引：
数据库中主键与索引的区别
加索引能使查询变快，加索引后会使写入、修改、删除变慢，占用存储空间 

索引的实现使用的数据结构：B+树
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。  
综上所述，如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。  

索引的种类：唯一索引、聚集索引、非聚集索引、覆盖索引
索引查询的流程：非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据  
索引数据结构设相关的计算机原理：磁盘预读原理 和 B+树
B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小


MySQL自适应索引(Adaptive hash index, AHI)实现解析
MySQL AHI 实现解析

AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。
AHI在内存中表现就是一个普通的哈希表对象，存储在btr_search_sys_t::hash_index中，对AHI的查删改操作都是通过一个全局读写锁btr_search_latch来保护。

MySQL 定位用户记录的过程可以描述为：
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上


---------------------------------------------------------------------------------------------------------------------  
SQL优化

参考  
SQL优化-执行计划-Hint.md


SQL优化原则：  
1、查询使用索引，避免查询索引失效的语句  
2、部分UPDATE、SELECT 语句 写得很复杂（经常嵌套多级子查询）拆分  
3、在可以使用UNION ALL的语句里，使用了UNION，UNION 因为会将各查询子集的记录做比较（去重），故比起UNION ALL ，通常速度都会慢上许多。  
4、限制使用select * from table这种方式：两者差别几乎可忽略。所以查询所有字段（或者大多数字段）的时候，大可select *来操作。如果某些不需要的字段数据量特别大，还是写清楚字段比较好，因为这样可以减少网络传输。考虑到今后的扩展性和可维护性，因为程序里面你需要使用到的列毕竟是确定的  
5、避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行，耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序  
6、慎重使用临时表可以极大的提高系统性能  
  

什么样的sql不走索引：where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等  
http://blog.csdn.net/bigtree_3721/article/details/72471206  
http://jaskey.github.io/blog/2016/01/19/mysql-bad-sql-with-no-index/  
 http://blog.csdn.net/m0_37808356/article/details/72526687  
   
   
 检查SQL是否使用了索引：用explain 来执行检验sql     
 mysql:key列显示MySQL实际决定使用的键（索引）  
 用explain 来执行检验sql 例如  
 explain select * from a  
   
 Explain用来分析 SQL 语句，分析结果中比较重要的字段有：  
 select_type : 查询类型，有简单查询、联合查询和子查询  
 key : 使用的索引  
 rows : 扫描的行数  
   
 oracle  
 explain Plan在sqlplus中使用起来非常的便捷，使用方法如下  
 sec@ora10g> explain plan for select count(*) from t;  
 
 
 MySQL为我们提供了一个分析sql语句执行计划的利器，那就是explain。通过explain我们可以分析一个sql语句完整的执行计划，包括使用的索引，扫描的行数以及是否使用了文件排序等等，在我们分析sql语句，优化sql语句中具有重要的意义。  
   
 MySQL：使用explain来分析sql语句:select_type(查询类型)，table（查询时使用的表名）、possible_keys（可能使用到的索引，不是最终使用的索引）、key（查询中真正使用的索引）、rows（sql执行过程中需要扫描到的行数。对于innodb引擎来说，这个值通常是一个估计值。这个值越小越好。）  
 Oracle：EXPLAIN PLAN FOR sql语句;  
 执行计划中字段解释：  
        ID: 一个序号，但不是执行的先后顺序。执行的先后根据缩进来判断。  
        Operation： 当前操作的内容。  
        Rows： 当前操作的Cardinality，Oracle估计当前操作的返回结果集。  
        Cost（CPU）：Oracle 计算出来的一个数值（代价），用于说明SQL执行的代价。  
        Time：Oracle 估计当前操作的时间。  
 
 
   
   
 深入理解 MySQL 底层实现  
 http://blog.csdn.net/gitchat/article/details/78787837  
 MySQL 的相关优化  
 1. MySQL 性能优化：组成、表的设计  
 开启查询缓存。避免某些 SQL 函数直接在 SQL 语句中使用，从而导致 Mysql 缓存失效。  
 避免画蛇添足。目的是什么就取什么，例如某个逻辑是只需要判断是否存在女性，若是查到了一条即可，勿要全部都查一遍，此时要善用 limit。  
 建合适的索引。所以要建在合适的地方，合适的对象上。经常操作 / 比较 / 判断的字段应该建索引。  
 字段大小合宜。字段的取值是有限而且是固定的，这种情况下可以用 enum，IP 字段可以用 unsigned int 来存储。  
 表的设计。垂直分割表，使得固定表与变长表分割，从而降低表的复杂度和字段的数目。  
   
 2. SQL 语句优化：避免全表扫描  
 建索引：一般在 where 及 order by 中涉及到的列上建索引，尽量不要对可以重复的字段建索引。  
 尽量避免在 where 中使用 !（<>）或 or，也不要进行 null 值判断。  
 尽量避免在 where 中对字段进行函数操作、表达式操作。  
 尽量避免使用 like- %，在此种情况下可以进行全文检索。  
   
 mysql分页查询：limit，oracle分页：ROWNUM  
   
 MySQL行级锁、表级锁、页级锁  
 http://www.jb51.net/article/50047.htm  
 http://www.hollischuang.com/archives/914  
 http://www.cnblogs.com/chenqionghe/p/4845693.html  
 页级:引擎 BDB。  
 表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行  
 行级:引擎 INNODB ， 单独的一行记录加锁  
   
 表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许  
 行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。  
 页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。  
   
   
 oracle的行级锁与表级锁  
 https://www.cnblogs.com/li1111xin/p/4775240.html  
   
 悲观锁（加的是表级锁）  
 一方：查询语句加 for update;另一方：查询语句加 for update;当进行更新语句的时候，另一方不能进行更新操作  
   
 乐观锁  
 更新语句设置版本号或者时间，在指定版本中更新数据  
   
 如果更新多，查询少，用悲观锁；反之，乐观锁  
 表级锁，where用的是非主键  
 行级锁，where用主键一般是id  
 如果用表级锁，其他客户将不能进行查询操作，因此开发中记得用行级锁  
 对于MySQL，如果表锁是读锁，可以并发读，如果是写锁，就会阻止读和写  
   
 查询慢可能原因：  
 1、数据量大  
 2、没有建主键和索引  
 3、sql中有排序  
 4、left join是相当耗资源的操作，如果关联的字段没有索引的话，速度是很慢的，所以如果有left join的话，最好用索引字段取关联。或者给关联的字段加索引，将left join右边的表数据补齐，然后将left join 替换为 inner join。我试过，速度确实快很多  
   
 一般不会影响查询效率：  
 sql包含数据处理函数，比如nvl函数,case when函数等  
 使用inner join查询  
   
   
 数据库中主键与索引的区别：  
 主键ID，主键既是约束也是索引，同时也用于对象缓存的键值。  
 区别:  
 1:主键是为了标识数据库记录唯一性,不允许记录重复,且键值不能为空,主键也是一个特殊索引.  
 2:数据表中只允许有一个主键,但是可以有多个索引.  
 3.使用主键会数据库会自动创建主索引,也可以在非主键上创建索引,方便查询效率.  
 4:索引可以提高查询速度,它就相当于字典的目录,可以通过它很快查询到想要的结果,而不需要进行全表扫描.  
 5:主键索引外索引的值可以为空.   
 6:主键也可以由多个字段组成,组成复合主键,同时主键肯定也是唯一索引.  
 7:唯一索引则表示该索引值唯一,可以由一个或几个字段组成,一个表可以有多个唯一索引.  
   
索引的种类：唯一索引、聚集索引、非聚集索引


索引建立：  
主键、数据量大、查询条件的字段，不要在对于大的文本字段甚至超长字段，不要建索引；  
  
1、避免对列的操作：在SQL编译的时候，就可以查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免全表扫描  
2、避免不必要的类型转换  
3、增加查询的范围限制  
4、尽量去掉"IN"、"OR"、 "<>"、去掉Where子句中的IS NULL和IS NOT NULL，因为使索引失效；  
不要在建立的索引的数据列上进行下列操作:  
◆避免对索引字段进行计算操作  
◆避免在索引字段上使用not，<>，!=  
◆避免在索引列上使用IS NULL和IS NOT NULL  
◆避免在索引列上出现数据类型转换  
◆避免在索引字段上使用函数  
◆避免建立索引的列中使用空值。  
在WHERE 语句中，尽量避免对索引字段进行计算操作  
where 中的like 使用了%express%,尽量固化查询字段，比如express%  
  
  
如果查询的表完全没有顺序，那么一个要返回记录数小于10％的查询可能会读取表中大部分的数据块，这样使用索引会使查询效率提高很多。但是如果表非常有顺序，那么如果查询的记录数大于40％时，可能使用全表扫描更快。因此，有一个索引范围扫描的总体原则是：  
      1) 对于原始排序的表  仅读取少于表记录数40％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的40％的查询应该使用全表扫描。  
      2) 对于未排序的表    仅读取少于表记录数7％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的7％的查询应该使用全表扫描。  
  
  
ANALYZE TABLE 作用的对象是 InnoDB, NDB, 和 MyISAM 表，对视图不起作用。在分析期间，会对表加上read lock(InnoDB, MyISAM) , 如果自从上次分析之后，表没有发生变化，则不会被再次分析。  
  
Cardinality 的意思是基数，也就是不重复的记录的数目，对于索引来讲，Cardinality越大越好，最好接近真实的记录数，如果Cardinality太小，则索引就失去意义了。  

   
 索引详解：  
 https://www.cnblogs.com/aspwebchh/p/6652855.html  
 http://blog.csdn.net/weiliangliang111/article/details/51333169  
 http://blog.csdn.net/suifeng3051/article/details/52669644  
 加索引能使查询变快，加索引后会使写入、修改、删除变慢，占用存储空间  
 主流的RDBMS都是把平衡树（平衡树」(非二叉)，也就是b tree或者 b+ tree，比如MySQL就普遍使用B+Tree实现其索引结构）当做数据表默认的索引数据结构的，有的数据库也使用哈希桶作用索引的数据结构  
 一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。  
 如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引，也就是所谓的「聚集索引」，这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。  
 平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。  
   
   
 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。  
   
 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。  
   
 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。  
   
 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据  
   
 索引查询的流程：
   
 这句SQL语句的执行过程如下  
 首先，通过非聚集索引查找到记录的主键ID值  
 然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置  
 最后， 从得到的真实数据中取得所查字段的值返回， 也就是取得最终的结果  
   
 覆盖索引：  
 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。  
 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。  
 所以如果只查询这两个字段，不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能  
   
 不加索引：  
 在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，必须一行一行的查找直到最后一行-这就意味数据库不得不检查上千行数据才能找到所以名字为Jesus的雇员。这就是所谓的全表扫描。  
   
   
   
 查找算法：  
 1、最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。   
 数据结构：有序或无序队列   
 复杂度：O(n)   
   
 2、二分查找（binary search）  
 数据结构：有序数组   
 复杂度：O(logn)   
   
 3、二叉排序树的特点是：  
   
 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；  
 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；  
 它的左、右子树也分别为二叉排序树。  
 搜索的原理：  
   
 若b是空树，则搜索失败，否则：  
 若x等于b的根节点的数据域之值，则查找成功；否则：  
 若x小于b的根节点的数据域之值，则搜索左子树；否则：  
 查找右子树。  
 数据结构：二叉排序树   
 时间复杂度： O(log2N)  
   
 4、哈希散列法(哈希表)  
 其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。  
   
 数据结构：哈希表   
 时间复杂度：几乎是O(1)，取决于产生冲突的多少，也就是链表长度，因为链表查找复杂度为O(n)  
   
 5、分块查找  
 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。   
   
 算法流程：  
 先选取各块中的最大关键字构成一个索引表；  
 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。  
   
   
 6、平衡多路搜索树B树（B-tree）  
 B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。  
   
 首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。  
 例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)  
   
 由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质  
   
   
 7、B+Tree  
 其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。  
   
   
 树的概念：  
 结点：指二叉树中一个个的点，就是下图中的0、1、2、3、4、5、6；  
 度：指父结点下面有几个孩子结点，举两个例子你就明白了。针对结点1，他下面有两个孩子3、4，所以说结点1的度为2；针对结点4，他下面一个孩子都没有，所以说结点4的度为0；叶子就是度为0的结点。  
 置于遍历有一点点麻烦，但要抓住以下要点就可以了（不管任何大小的树）：  
 前序：是先访问根，再访问左子树，然后访问右子树  
 后序：是先访问左子树，再访问右子树，然后访问根  
 中序：是先访问左子树，再访问根，然后访问右子树  
 完全二叉树，除了叶子结点这层外，其他层结点都是度为2的，所以这样的树高度应该最矮了。  
 以下图为例子：  
 前序序列：0134256后序序列：3415620中序序列：3140526  
 ![http连接过程图片](./image/treeSort.png.jpeg "ReferencePicture")  
   
  
  
图论（离散数学）：  
  
出度和入度  
可以把人与人之间为识的关系对应到一个图中。如果a认识b就a->b连一条边。  
有向图来说，结常与结点间的连接。V1到V2，V1到V3。说明V1的出度是2。V2到V1说明V1的入度是1  
  
数据结构中入度出度分别用什么符号表示  
入度：ID in degree  
出度：OD out degree  
  
有向图顶点集的度数是不是等于出度加入度  
在一个有向图中，所有顶点的入度之和等于所有顶点出度之和，一条边必有起点和终点，这是同时存在的，不存在一条边只有起点或者只有终点，所以所有顶点的入度之和等于所有顶点出度之和  
  
在有向图中，入度高的点和出度高的点各自的含义是不同的。粗浅地说，出度高的点我们往往叫做Authority，就是那种权威性很好，所以对其他点影响力较强或者输出信息较多的点。而相应的，入度比较高的点称为Hub，即那种作为中介的，从别人那里获取信息比较多的点。当然，计算Authority和Hub更权威的方法有HITS算法等，往往并非单纯依赖出入度这么简单。  
  
度数这个概念仅适用于无向图，即相邻的点的个数（或者说是连接的边的个数）。在有向图中，一般来说只分开考虑入度和出度，基本上见不到说把两者加起来记做度数的。  
  
  
索引数据结构设相关的计算机原理：  
  
在计算机系统中一般包含两种类型的存储，计算机主存（RAM）和外部存储器（如硬盘、CD、SSD等）。主存的读取速度快，相对于主存，外部磁盘的数据读取速率要比主从慢好几个数量级，具体它们之间的差别后面会详细介绍。 上面讲的所有查询算法都是假设数据存储在计算机主存中的，计算机主存一般比较小，  
实际数据库中数据都是存储到外部存储器的。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
  
当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。  
写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。  
主存存取的时间仅与存取次数呈线性关系  
  
磁盘存取原理：每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分  
当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区  
为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间  
然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间  
最后便是对读取数据的传输  
所以每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分  
  
寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。  
旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。  
传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。  
  
局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。  
磁盘预读：由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。  
  
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。  

索引的实现使用的数据结构：B+树，
  
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。  
综上所述，如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。  
  
B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：  
dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整  
由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。  
  
真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。  


---------------------------------------------------------------------------------------------------------------------  
MySQL自适应索引(Adaptive hash index, AHI)实现解析
MySQL AHI 实现解析

AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。
AHI在内存中表现就是一个普通的哈希表对象，存储在btr_search_sys_t::hash_index中，对AHI的查删改操作都是通过一个全局读写锁btr_search_latch来保护。

MySQL 定位用户记录的过程可以描述为：
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上



我们知道InnoDB的索引组织结构为Btree。通常情况下，我们需要根据查询条件，从根节点开始寻路到叶子节点，找到满足条件的记录。为了减少寻路开销，InnoDB本身做了几点优化。

1、首先，对于连续记录扫描，InnoDB在满足比较严格的条件时采用row cache的方式连续读取8条记录（并将记录格式转换成MySQL Format），存储在线程私有的row_prebuilt_t::fetch_cache中；
这样一次寻路就可以获取多条记录，在server层处理完一条记录后，可以直接从cache中取数据而无需再次寻路，直到cache中数据取完，再进行下一轮。

2、另一种方式是，当一次进入InnoDB层获得数据后，在返回server层前，当前在btree上的cursor会被暂时存储到row_prebuilt_t::pcur中，
当再次返回InnoDB层捞数据时，如果对应的Block没有发生任何修改，则可以继续沿用之前存储的cursor，无需重新定位。

AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。


MySQL 定位用户记录的过程可以描述为：
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上

如果树高为 N, 则需要读取索引树上的 N 个结点并进行比较，如果 buffer_pool 较小，则大量的操作都会在 pread 上，用户响应时间变长；
另外，MySQL中 Server 层与 Engine 之间的是以 row 为单位进行交互的，engine 将记录返回给 server 层，server 层对 engine 的行数据进行相应的计算，然后缓存或发送至客户端，

为了减少交互过程所需要的时间，MySQL 做了两个优化：
1、如果同一个查询语句连续取出了 MYSQL_FETCH_CACHE_THRESHOLD(4) 条记录，则会调用函数 row_sel_enqueue_cache_row_for_mysql 将 MYSQL_FETCH_CACHE_SIZE(8) 记录缓存至 prebuilt->fetch_cache 中，
在随后的 prebuilt->n_fetch_cached 次交互中，都会从prebuilt->fetch_cache 中直接取数据返回到 server 层，
那么问题来了，即使是用户只需要 4 条数据，Engine 层也会将 MYSQL_FETCH_CACHE_SIZE 条数据放入 fetch_cache 中，造成了不必要的缓存使用。
另外， 5.7 可以根据用户的设置来调整缓存用户记录的条数；

2、Engine 取出数据后，会将 cursor 的位置保存起来，
当取下一条数据时，会尝试恢复 cursor 的位置，成功则并继续取下一条数据，否则会重新定位 cursor 的位置，
从而通过保存 cursor 位置的方法可以减少 server 层 & engine 层交互的时间；


AHI 功能作用
由以上的分析可以看到 MySQL 一次定位 cursor 的过程即是从根结点到叶子结点的路径，时间复杂度为：height(index) + [CPU cost time]，
上述的两个优化过程无法省略定位 cursor 的中间结点，因此需要引入一种可以从 search info 定位到叶子结点的方法，从而省略根结点到叶子结点的路径上所消耗的时间，而这种方法即是 自适应索引(Adaptive hash index, AHI)。

查询语句使用 AHI 的时候有以下优点：
1、可以直接通过从查询条件直接定位到叶子结点，减少一次定位所需要的时间
2、在 buffer pool 不足的情况下，可以只针对热点数据页建立缓存，从而避免数据页频繁的 LRU

但是AHI 并不总能提升性能，在多表Join & 模糊查询 & 查询条件经常变化的情况下，此时系统监控 AHI 使用的资源大于上述的好处时，不仅不能发挥 AHI 的优点，还会为系统带来额外的 CPU 消耗，此时需要将 AHI 关闭来避免不必要的系统资源浪费，
关于 AHI 的适应场景可以参考：mysql_adaptive_hash_index_implementation。
https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/innodb-adaptive-hash.html




Linux系统函数read()/write()/pread()/pwrite()的区别
参考
/Users/yangzl/git/quickstart-framework/quickstart-linux/docs/linux/learn/Linux系统函数read()write()pread()pwrite()的区别.md

pread函数用于从打开文件的指定位置开始读取数据
pwrite函数用于从打开文件的指定位置处写入指定字节的数据

函数原型
Ssize_t pread(int fd,void *buf,size_t nbytes,off_t offset);
Ssize_t write(int fd,const void *buf,size_t nbytes,off_t offset);

pread相当于先调用lseek接着调用read。但又不完全是这样：
（1）pread是原子操作，定位和读操作在一个原子操作中完成，期间不可中断。但分开的lseek和read中间可能被其他程序中断。
（2）pread不更改当前文件的指针，也就是说不改变当前文件偏移量。
（3）pread中的offset是一个绝对量，相对于文件开始处的绝对量，与当前文件指针位置无关。


pwrite相当于先调用lseek接着调用write。但又不完全是这样：
（1）pwrite是原子操作，定位和写操作在一个原子操作中完成，期间不可中断。但分开的lseek和write中间可能被其他程序中断。
（2）pwrite不更改当前文件的指针，也就是说不改变当前文件偏移量。
（3）pwrite中的offset是一个绝对量，相对于文件开始处的绝对量，与当前文件指针位置无关。




参考
http://mysql.taobao.org/monthly/2015/09/01/
https://cloud.tencent.com/developer/article/1004516
https://dbaplus.cn/news-11-963-1.html


---------------------------------------------------------------------------------------------------------------------  


  