- [深入理解MySQL底层实现](#深入理解MySQL底层实现)
- [为什么要给表加上主键](#为什么要给表加上主键)
- [MySQL慢查询可能原因](#MySQL慢查询可能原因)
- [主键与索引的区别](#主键与索引的区别)
- [索引详解](#索引详解)
    - [索引的数据结构](#索引的数据结构)
    - [深入理解MySQL索引底层实现原理](#深入理解MySQL索引底层实现原理)
    - [索引数据结构设相关的计算机原理](#索引数据结构设相关的计算机原理) ：磁盘预读原理 和 B+树
        - [磁盘存取原理](#磁盘存取原理)
        - [局部性原理](#局部性原理)
        - [磁盘预读](#磁盘预读)
    - [索引的创建原则](#索引的创建原则)
    - [索引的种类](#索引的种类)
    - [MYSQL索引：对聚簇索引和非聚簇索引的认识](#MYSQL索引：对聚簇索引和非聚簇索引的认识)
    - [索引的优缺点](#索引的优缺点)
    - [索引查询的流程](#索引查询的流程)
- [查找算法](#查找算法)
- [树的概念](#树的概念)
- [图论（离散数学）](#图论（离散数学）)
- [数据库优化](#数据库优化)
    - [SQL优化](#SQL优化)
        - [SQL优化原则](#SQL优化原则)
        - [什么样的SQL不走索引](#什么样的SQL不走索引)
        - [检查SQL是否使用了索引](#检查SQL是否使用了索引)
        - [SQL优化具体原理原则](#SQL优化具体原理原则)
- [MySQL自适应索引](#MySQL自适应索引)
    - MySQL AHI 实现解析
    - MySQL定位用户记录的过程可以描述为
    - AHI功能作用
    - 查询语句使用AHI的时候有以下优点
- [索引条件下推优化（Index Condition Pushdown (ICP) ）](#索引条件下推优化)
- [Linux系统函数read()/write()/pread()/pwrite()的区别](#Linux系统函数read()/write()/pread()/pwrite()的区别)


MySQL索引的原理和数据结构能介绍一下吗？
b+树和b-树有什么区别？
MySQL聚簇索引和非聚簇索引的区别是什么？
他们分别是如何存储的？
使用MySQL索引都有哪些原则？
MySQL复合索引如何使用？

索引的使用规则：最左匹配原则
索引的分类
索引的建立的原则有哪些
在哪些字段上建立索引
索引失效的情况
SQL优化
索引的缺点以及使用注意

1、索引原理
2、索引分类（Index Class）
3、索引操作
4、索引使用策略
5、总结



红黑树和平衡二叉树的区别，各自的优势特点，以及红黑树如何进行添加数据「具体说一下旋转过程」

mysql分页查询：limit，oracle分页：ROWNUM



---------------------------------------------------------------------------------------------------------------------

## 深入理解MySQL底层实现

MySQL的常用引擎
1. InnoDB
2. Myisam
3. 存储结构  
    InnoDB 和 Myisam 都是用 B+Tree 来存储数据的。


MySQL的数据、索引存储结构
1. 数据存储的原理（硬盘）
2. 数据读写的原理
3. 访盘请求完成过程
4. 磁盘的读写原理
5. 减少I/O的预读原理
6. MySQL的索引
7. MySQL的B+Tree
8. Myisam中的B+Tree
9. InnoDB中的B+Tree



MySQL的相关优化
1. MySQL性能优化：组成、表的设计
2. SQL语句优化：避免全表扫描



[深入理解MySQL底层实现](https://blog.csdn.net/gitchat/article/details/78787837)

---------------------------------------------------------------------------------------------------------------------
## 为什么要给表加上主键

平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。

一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。

如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。

没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。

非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。



---------------------------------------------------------------------------------------------------------------------
### MySQL慢查询可能原因
1、数据量大  
2、没有建主键和索引  
3、sql中有排序  
4、left join是相当耗资源的操作，如果关联的字段没有索引的话，速度是很慢的，所以如果有left join的话，最好用索引字段取关联。或者给关联的字段加索引，将left join右边的表数据补齐，然后将left join 替换为 inner join。我试过，速度确实快很多  

一般不会影响查询效率：  
sql包含数据处理函数，比如nvl函数,case when函数等  
使用inner join查询  


---------------------------------------------------------------------------------------------------------------------

## 主键与索引的区别

 数据库中主键与索引的区别：  
 主键ID，主键既是约束也是索引，同时也用于对象缓存的键值。  
 
 区别:
 1. 主键是为了标识数据库记录唯一性,索引是为了提高查询效率
 2. 主键既是约束也是索引,索引没有约束效力
 3. 主键是唯一不能为空的
 4. 索引是值可以为空，可以有多个索引


 1. 主键是为了标识数据库记录唯一性,不允许记录重复,且键值不能为空,主键也是一个特殊索引.主键索引外索引的值可以为空.
 2. 使用主键会数据库会自动创建主索引,也可以在非主键上创建索引,方便查询效率.  
 3. 数据表中只允许有一个主键,但是可以有多个索引.  
 4. 主键也可以由多个字段组成,组成复合主键,同时主键肯定也是唯一索引.
 5. 唯一索引则表示该索引值唯一,可以由一个或几个字段组成,一个表可以有多个唯一索引.
 6. 索引可以提高查询速度,它就相当于字典的目录,可以通过它很快查询到想要的结果,而不需要进行全表扫描.  


---------------------------------------------------------------------------------------------------------------------
## 索引详解

- [索引的数据结构](#索引的数据结构)
- [深入理解MySQL索引底层实现原理](#深入理解MySQL索引底层实现原理)
- [索引数据结构设相关的计算机原理](#索引数据结构设相关的计算机原理) 
    - [磁盘存取原理](#磁盘存取原理)
    - [局部性原理](#局部性原理)
    - [磁盘预读](#磁盘预读)
- [索引的创建原则](#索引的创建原则)
- [索引的种类](#索引的种类)
- [MYSQL索引：对聚簇索引和非聚簇索引的认识](#MYSQL索引：对聚簇索引和非聚簇索引的认识)
- [索引的优缺点](#索引的优缺点)
- [索引查询的流程](#索引查询的流程)


 
加索引能使查询变快，加索引后会使写入、修改、删除变慢，占用存储空间  

主流的RDBMS都是把平衡树（平衡树」(非二叉)，也就是b tree或者 b+ tree，比如MySQL就普遍使用B+Tree实现其索引结构）当做数据表默认的索引数据结构的，有的数据库也使用哈希桶作用索引的数据结构  

一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。  

如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引，也就是所谓的「聚集索引」，这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。  

平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。  
   
   
索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。  
   
非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。  
   
每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。  
   
非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据  
   

https://www.cnblogs.com/aspwebchh/p/6652855.html  
http://blog.csdn.net/weiliangliang111/article/details/51333169  
http://blog.csdn.net/suifeng3051/article/details/52669644  

## 索引的数据结构

索引的实现使用的数据结构：B+树（平衡树）  
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。  
综上所述，如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。  

  
B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。  
B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：  
dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整  
由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。  

真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。 


想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者 b+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。


- 1、增大出度，B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。
- 2、另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。
- 3、数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。



## 深入理解MySQL索引底层实现原理

- 1、增大出度，B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。
- 2、另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。
- 3、数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。


局部性与页：操作系统按照页加载数据，操作系统的局部性原理，一次会加载一页的数据，不仅仅是需要的数据，会多加载

show global status like 'Innodb_page_size';
通过上面的sql我们知道此时使用的Innodb存储引擎所对应的页大小是16384  也就是16384/1024 = 16KB。


[深入理解MySQL索引底层实现原理](https://zhuanlan.zhihu.com/p/77383599)  
[深入浅出数据库索引原理](https://www.cnblogs.com/aspwebchh/p/6652855.html)  
[MySQL innoDB索引底层原理详解](https://blog.csdn.net/u012978884/article/details/52416997)  



## 索引的创建原则

每次数据修改都要维护索引的结构，所以唯一性较差，或者频繁修改的字段，我们不应该建立索引

唯一性较高，经常作为查询或者过滤条件或者排序条件的字段建立索引，一张表建立索引的字段个数是有限制的，最多对16个字段建立索引

导致索引失效的SQL：比如

索引建立：  
主键、数据量大、查询条件的字段，不要在对于大的文本字段甚至超长字段，不要建索引；  
  
1、避免对列的操作：在SQL编译的时候，就可以查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免全表扫描  
2、避免不必要的类型转换  
3、增加查询的范围限制  
4、尽量去掉"IN"、"OR"、 "<>"、去掉Where子句中的IS NULL和IS NOT NULL，因为使索引失效；  
不要在建立的索引的数据列上进行下列操作:  
◆避免对索引字段进行计算操作  
◆避免在索引字段上使用not，<>，!=  
◆避免在索引列上使用IS NULL和IS NOT NULL  
◆避免在索引列上出现数据类型转换  
◆避免在索引字段上使用函数  
◆避免建立索引的列中使用空值。  
在WHERE 语句中，尽量避免对索引字段进行计算操作  
where 中的like 使用了%express%,尽量固化查询字段，比如express%  

如果查询的表完全没有顺序，那么一个要返回记录数小于10％的查询可能会读取表中大部分的数据块，这样使用索引会使查询效率提高很多。

但是如果表非常有顺序，那么如果查询的记录数大于40％时，可能使用全表扫描更快。因此，有一个索引范围扫描的总体原则是：  
      1) 对于原始排序的表  仅读取少于表记录数40％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的40％的查询应该使用全表扫描。  
      2) 对于未排序的表    仅读取少于表记录数7％的查询应该使用索引范围扫描。反之，读取记录数目多于表记录数的7％的查询应该使用全表扫描。  
  
  
ANALYZE TABLE 作用的对象是 InnoDB, NDB, 和 MyISAM 表，对视图不起作用。在分析期间，会对表加上read lock(InnoDB, MyISAM) , 如果自从上次分析之后，表没有发生变化，则不会被再次分析。  
  
Cardinality 的意思是基数，也就是不重复的记录的数目，对于索引来讲，Cardinality越大越好，最好接近真实的记录数，如果Cardinality太小，则索引就失去意义了。  


## 索引的种类

索引的种类：唯一索引、聚集索引、非聚集索引、覆盖索引

组合索引：AND条件，并且遵循最左匹配原则

[多个单列索引和联合索引的区别详解](https://blog.csdn.net/Abysscarry/article/details/80792876)  
[MySQL单列索引和组合索引](https://blog.csdn.net/xlxxcc/article/details/51150824)  





## MYSQL索引：对聚簇索引和非聚簇索引的认识

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。  
一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

InnoDB中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值.

InnoDB聚簇索引
1. InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
2. 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

注意：聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)。



MYISAM是按列值与行号来组织索引的。它的叶子节点中保存的实际上是指向存放数据的物理块的指针。  
从MYISAM存储的物理文件我们能看出，MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的。



### INNODB的二级索引
INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。

InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。


### MyISAM的二级索引
而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是数据的物理地址。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。



### 聚簇索引和非聚簇索引区别

- 聚簇索引（INNODB引擎的索引结构）：聚簇索引的叶子节点就是数据节点。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。
    - 主键索引：叶子节点就是行数据，
    - 二级索引（辅助索引）：叶子节点是主键值，还要再查询主键索引获取行数据
- 非聚簇索引（MyISAM引擎的索引结构）：而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。



### 辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处

### 聚簇索引的优势
1. 由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 ID 来组织数据，获得数据更快。
2. 辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。



### 为什么主键通常建议使用自增id
聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）

不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。


[MYSQL索引：对聚簇索引和非聚簇索引的认识](https://blog.csdn.net/alexdamiao/article/details/51934917)  
[MySQL 聚簇索引和非聚簇索引 & mysql 索引为啥用b 树](https://blog.csdn.net/universsky2015/article/details/102712058)  





## 索引的优缺点

优点：
1. 加索引能使查询变快，

缺点：
1. 加索引后会使写入、修改、删除变慢，维护平衡树的结构，
2. 增加表的体积，多占用存储空间 


因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构

每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。



## 索引查询的流程

索引查询的流程：非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ，再使用主键的值通过聚集索引查找到需要的数据 

MySQL定位用户记录的过程可以描述为：  
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上


索引查询的流程：

这句SQL语句的执行过程如下  
首先，通过非聚集索引查找到记录的主键ID值  
然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置  
最后， 从得到的真实数据中取得所查字段的值返回， 也就是取得最终的结果  


覆盖索引：  
有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。  
当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。  
所以如果只查询这两个字段，不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能  


不加索引：  
在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，必须一行一行的查找直到最后一行-这就意味数据库不得不检查上千行数据才能找到所以名字为Jesus的雇员。这就是所谓的全表扫描。  


---------------------------------------------------------------------------------------------------------------------

## 数据库优化


MySQL 的相关优化  
1. MySQL 性能优化：组成、表的设计  
开启查询缓存。避免某些 SQL 函数直接在 SQL 语句中使用，从而导致 Mysql 缓存失效。  
避免画蛇添足。目的是什么就取什么，例如某个逻辑是只需要判断是否存在女性，若是查到了一条即可，勿要全部都查一遍，此时要善用 limit。  
建合适的索引。所以要建在合适的地方，合适的对象上。经常操作 / 比较 / 判断的字段应该建索引。  
字段大小合宜。字段的取值是有限而且是固定的，这种情况下可以用 enum，IP 字段可以用unsigned int 来存储。  
表的设计。垂直分割表，使得固定表与变长表分割，从而降低表的复杂度和字段的数目。  

2. SQL 语句优化：避免全表扫描  
建索引：一般在 where 及 order by 中涉及到的列上建索引，尽量不要对可以重复的字段建索引。  
尽量避免在 where 中使用 !（<>）或 or，也不要进行 null 值判断。  
尽量避免在 where 中对字段进行函数操作、表达式操作。  
尽量避免使用 like- %，在此种情况下可以进行全文检索。  


1) SQL语句及索引的优化  
2、开启查询缓存。避免某些 SQL 函数直接在 SQL 语句中使用，从而导致 Mysql 缓存失效。  
3) 数据库表结构的优化：冗余  
4) 其他组件的缓存：Redis缓存、本地缓存  
5) 读写分离  
6) 分库分表  

数据库架构扩展：主从复制与读写分离、增加缓存、分库、分表、分区，开启慢查询日志，  
4) 系统配置的优化  
5) 硬件优化  


## SQL优化

[SQL优化-执行计划-Hint](../../docs/SQL/SQL优化-执行计划-Hint.md)

1. SQL优化原则
2. 什么样的SQL不走索引
3. 检查SQL是否使用了索引
4. SQL优化具体原理原则
5. 


什么样的sql不走索引：where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等 
检查SQL是否使用了索引：用explain 来执行检验sql  
mysql:key 列显示MySQL实际决定使用的键（索引）  
SQL语句优化：避免全表扫描  
MySQL行级锁、表级锁、页级锁的优化  




### SQL优化原则
1、查询使用索引，避免查询索引失效的语句  
2、部分UPDATE、SELECT 语句 写得很复杂（经常嵌套多级子查询）拆分  
3、在可以使用UNION ALL的语句里，使用了UNION，UNION 因为会将各查询子集的记录做比较（去重），故比起UNION ALL ，通常速度都会慢上许多。  
4、限制使用select * from table这种方式：两者差别几乎可忽略。所以查询所有字段（或者大多数字段）的时候，大可select *来操作。如果某些不需要的字段数据量特别大，还是写清楚字段比较好，因为这样可以减少网络传输。考虑到今后的扩展性和可维护性，因为程序里面你需要使用到的列毕竟是确定的  
5、避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行，耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序  
6、慎重使用临时表可以极大的提高系统性能  


  
### 什么样的SQL不走索引
where条件上索引列有计算、比较等操作，%%通配符，使用or关键字等等  
http://blog.csdn.net/bigtree_3721/article/details/72471206  
http://jaskey.github.io/blog/2016/01/19/mysql-bad-sql-with-no-index/  
 http://blog.csdn.net/m0_37808356/article/details/72526687  


### 检查SQL是否使用了索引
用explain 来执行检验sql     
 mysql:key列显示MySQL实际决定使用的键（索引）  
 用explain 来执行检验sql 例如  
 explain select * from a  
   
 Explain用来分析 SQL 语句，分析结果中比较重要的字段有：  
 select_type : 查询类型，有简单查询、联合查询和子查询  
 key : 使用的索引  
 rows : 扫描的行数  
   
 oracle  
 explain Plan在sqlplus中使用起来非常的便捷，使用方法如下  
 sec@ora10g> explain plan for select count(*) from t;  
 
 
 MySQL为我们提供了一个分析sql语句执行计划的利器，那就是explain。通过explain我们可以分析一个sql语句完整的执行计划，包括使用的索引，扫描的行数以及是否使用了文件排序等等，在我们分析sql语句，优化sql语句中具有重要的意义。  
   
 MySQL：使用explain来分析sql语句:select_type(查询类型)，table（查询时使用的表名）、possible_keys（可能使用到的索引，不是最终使用的索引）、key（查询中真正使用的索引）、rows（sql执行过程中需要扫描到的行数。对于innodb引擎来说，这个值通常是一个估计值。这个值越小越好。）  
 Oracle：EXPLAIN PLAN FOR sql语句;  
 执行计划中字段解释：  
  ID: 一个序号，但不是执行的先后顺序。执行的先后根据缩进来判断。  
  Operation： 当前操作的内容。  
  Rows： 当前操作的Cardinality，Oracle估计当前操作的返回结果集。  
  Cost（CPU）：Oracle 计算出来的一个数值（代价），用于说明SQL执行的代价。  
  Time：Oracle 估计当前操作的时间。  



### SQL优化具体原理原则
1、查询SQL尽量不要使用select *，而是select具体字段。
2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1
3、应尽量避免在where子句中使用or来连接条件，使用or可能会使索引失效，从而全表扫描。
4、优化limit分页，我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。
5、优化你的like语句，符合最左匹配原则
6、使用where条件限定要查询的数据，避免返回多余的行
7、尽量避免在索引列上使用mysql的内置函数
8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫
9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小
10、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。
13、如果插入数据过多，考虑批量插入。
14、在适当的时候，使用覆盖索引。
15、慎用distinct关键字：distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。
16、删除冗余和重复索引
17、如果数据量较大，优化你的修改/删除语句。
18、where子句中考虑使用默认值代替null。
19、不要有超过5个以上的表连接
20、exist & in的合理利用
21、尽量用 union all 替换 union：如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。
22、索引不宜太多，一般5个以内。
23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型
24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。
25、尽量避免向客户端返回过多数据量。
26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。
27、尽可能使用varchar/nvarchar 代替 char/nchar。
28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。
29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效
30、使用explain 分析你SQL的计划


---------------------------------------------------------------------------------------------------------------------

## 索引数据结构设相关的计算机原理
  
在计算机系统中一般包含两种类型的存储，计算机主存（RAM）和外部存储器（如硬盘、CD、SSD等）。主存的读取速度快，相对于主存，外部磁盘的数据读取速率要比主从慢好几个数量级，具体它们之间的差别后面会详细介绍。 上面讲的所有查询算法都是假设数据存储在计算机主存中的，计算机主存一般比较小，  
实际数据库中数据都是存储到外部存储器的。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
  
当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。  
写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。  
主存存取的时间仅与存取次数呈线性关系  


### 磁盘存取原理
磁盘存取原理：每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分  
当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区  
为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间  
然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间  
最后便是对读取数据的传输  
所以每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分  
  
寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。  
旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。  
传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。  


### 局部性原理
局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。

### 磁盘预读
磁盘预读：由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。  
  
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。  



---------------------------------------------------------------------------------------------------------------------
## 查找算法

1、最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。   
数据结构：有序或无序队列   
复杂度：O(n)   
   
2、二分查找（binary search）  
数据结构：有序数组   
复杂度：O(logn)   
   
3、二叉排序树的特点是：  
   
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；  
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；  
它的左、右子树也分别为二叉排序树。  
搜索的原理：  
   
若b是空树，则搜索失败，否则：  
若x等于b的根节点的数据域之值，则查找成功；否则：  
若x小于b的根节点的数据域之值，则搜索左子树；否则：  
查找右子树。  
数据结构：二叉排序树   
时间复杂度： O(log2N)  
   
4、哈希散列法(哈希表)  
其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。  
   
数据结构：哈希表   
时间复杂度：几乎是O(1)，取决于产生冲突的多少，也就是链表长度，因为链表查找复杂度为O(n)  
   
5、分块查找  
分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。   
   
算法流程：  
先选取各块中的最大关键字构成一个索引表；  
查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。  
   
   
6、平衡多路搜索树B树（B-tree）  
B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。  
   
首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。  
例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)  
   
由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质  
   
   
7、B+Tree  
其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。  


---------------------------------------------------------------------------------------------------------------------
## 树的概念

结点：指二叉树中一个个的点，就是下图中的0、1、2、3、4、5、6；  
度：指父结点下面有几个孩子结点，举两个例子你就明白了。针对结点1，他下面有两个孩子3、4，所以说结点1的度为2；针对结点4，他下面一个孩子都没有，所以说结点4的度为0；叶子就是度为0的结点。  
置于遍历有一点点麻烦，但要抓住以下要点就可以了（不管任何大小的树）：  
前序：是先访问根，再访问左子树，然后访问右子树  
后序：是先访问左子树，再访问右子树，然后访问根  
中序：是先访问左子树，再访问根，然后访问右子树  
完全二叉树，除了叶子结点这层外，其他层结点都是度为2的，所以这样的树高度应该最矮了。  
以下图为例子：  
前序序列：0134256后序序列：3415620中序序列：3140526  
![http连接过程图片](./image/treeSort.png.jpeg "ReferencePicture")  


---------------------------------------------------------------------------------------------------------------------
## 图论（离散数学）

出度和入度  
可以把人与人之间为识的关系对应到一个图中。如果a认识b就a->b连一条边。  
有向图来说，结常与结点间的连接。V1到V2，V1到V3。说明V1的出度是2。V2到V1说明V1的入度是1  
  
数据结构中入度出度分别用什么符号表示  
入度：ID in degree  
出度：OD out degree  
  
有向图顶点集的度数是不是等于出度加入度  
在一个有向图中，所有顶点的入度之和等于所有顶点出度之和，一条边必有起点和终点，这是同时存在的，不存在一条边只有起点或者只有终点，所以所有顶点的入度之和等于所有顶点出度之和  
  
在有向图中，入度高的点和出度高的点各自的含义是不同的。粗浅地说，出度高的点我们往往叫做Authority，就是那种权威性很好，所以对其他点影响力较强或者输出信息较多的点。而相应的，入度比较高的点称为Hub，即那种作为中介的，从别人那里获取信息比较多的点。当然，计算Authority和Hub更权威的方法有HITS算法等，往往并非单纯依赖出入度这么简单。  
  
度数这个概念仅适用于无向图，即相邻的点的个数（或者说是连接的边的个数）。在有向图中，一般来说只分开考虑入度和出度，基本上见不到说把两者加起来记做度数的。  


---------------------------------------------------------------------------------------------------------------------  
## MySQL自适应索引

MySQL自适应索引(Adaptive hash index, AHI)实现解析
MySQL AHI 实现解析

AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。
AHI在内存中表现就是一个普通的哈希表对象，存储在btr_search_sys_t::hash_index中，对AHI的查删改操作都是通过一个全局读写锁btr_search_latch来保护。

MySQL定位用户记录的过程可以描述为：
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上


### MySQL AHI 实现解析
我们知道InnoDB的索引组织结构为Btree。通常情况下，我们需要根据查询条件，从根节点开始寻路到叶子节点，找到满足条件的记录。为了减少寻路开销，InnoDB本身做了几点优化。

1、首先，对于连续记录扫描，InnoDB在满足比较严格的条件时采用row cache的方式连续读取8条记录（并将记录格式转换成MySQL Format），存储在线程私有的row_prebuilt_t::fetch_cache中；
这样一次寻路就可以获取多条记录，在server层处理完一条记录后，可以直接从cache中取数据而无需再次寻路，直到cache中数据取完，再进行下一轮。

2、另一种方式是，当一次进入InnoDB层获得数据后，在返回server层前，当前在btree上的cursor会被暂时存储到row_prebuilt_t::pcur中，
当再次返回InnoDB层捞数据时，如果对应的Block没有发生任何修改，则可以继续沿用之前存储的cursor，无需重新定位。



### MySQL定位用户记录的过程可以描述为
打开索引 -> 根据索引键值逐层查找 B+ 树 branch 结点 -> 定位到叶子结点，将 cursor 定位到满足条件的 rec（record） 上

如果树高为 N, 则需要读取索引树上的 N 个结点并进行比较，如果 buffer_pool 较小，则大量的操作都会在 pread 上，用户响应时间变长；
另外，MySQL中 Server 层与 Engine 之间的是以 row 为单位进行交互的，engine 将记录返回给 server 层，server 层对 engine 的行数据进行相应的计算，然后缓存或发送至客户端，

为了减少交互过程所需要的时间，MySQL 做了两个优化：
1、如果同一个查询语句连续取出了 MYSQL_FETCH_CACHE_THRESHOLD(4) 条记录，则会调用函数 row_sel_enqueue_cache_row_for_mysql 将 MYSQL_FETCH_CACHE_SIZE(8) 记录缓存至 prebuilt->fetch_cache 中，
在随后的 prebuilt->n_fetch_cached 次交互中，都会从prebuilt->fetch_cache 中直接取数据返回到 server 层，
那么问题来了，即使是用户只需要 4 条数据，Engine 层也会将 MYSQL_FETCH_CACHE_SIZE 条数据放入 fetch_cache 中，造成了不必要的缓存使用。
另外， 5.7 可以根据用户的设置来调整缓存用户记录的条数；

2、Engine 取出数据后，会将 cursor 的位置保存起来，
当取下一条数据时，会尝试恢复 cursor 的位置，成功则并继续取下一条数据，否则会重新定位 cursor 的位置，
从而通过保存 cursor 位置的方法可以减少 server 层 & engine 层交互的时间；


### AHI功能作用  
由以上的分析可以看到 MySQL 一次定位 cursor 的过程即是从根结点到叶子结点的路径，时间复杂度为：height(index) + [CPU cost time]，
上述的两个优化过程无法省略定位 cursor 的中间结点，因此需要引入一种可以从 search info 定位到叶子结点的方法，从而省略根结点到叶子结点的路径上所消耗的时间，而这种方法即是 自适应索引(Adaptive hash index, AHI)。

### 查询语句使用AHI的时候有以下优点
1、可以直接通过从查询条件直接定位到叶子结点，减少一次定位所需要的时间
2、在 buffer pool 不足的情况下，可以只针对热点数据页建立缓存，从而避免数据页频繁的 LRU

但是AHI 并不总能提升性能，在多表Join & 模糊查询 & 查询条件经常变化的情况下，此时系统监控 AHI 使用的资源大于上述的好处时，不仅不能发挥 AHI 的优点，还会为系统带来额外的 CPU 消耗，此时需要将 AHI 关闭来避免不必要的系统资源浪费，
关于 AHI 的适应场景可以参考：mysql_adaptive_hash_index_implementation。
https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/innodb-adaptive-hash.html


---------------------------------------------------------------------------------------------------------------------

## Linux系统函数read()/write()/pread()/pwrite()的区别
参考
/Users/yangzl/git/quickstart-framework/quickstart-linux/docs/linux/learn/Linux系统函数read()write()pread()pwrite()的区别.md

pread函数用于从打开文件的指定位置开始读取数据
pwrite函数用于从打开文件的指定位置处写入指定字节的数据

函数原型
Ssize_t pread(int fd,void *buf,size_t nbytes,off_t offset);
Ssize_t write(int fd,const void *buf,size_t nbytes,off_t offset);

pread相当于先调用lseek接着调用read。但又不完全是这样：
（1）pread是原子操作，定位和读操作在一个原子操作中完成，期间不可中断。但分开的lseek和read中间可能被其他程序中断。
（2）pread不更改当前文件的指针，也就是说不改变当前文件偏移量。
（3）pread中的offset是一个绝对量，相对于文件开始处的绝对量，与当前文件指针位置无关。


pwrite相当于先调用lseek接着调用write。但又不完全是这样：
（1）pwrite是原子操作，定位和写操作在一个原子操作中完成，期间不可中断。但分开的lseek和write中间可能被其他程序中断。
（2）pwrite不更改当前文件的指针，也就是说不改变当前文件偏移量。
（3）pwrite中的offset是一个绝对量，相对于文件开始处的绝对量，与当前文件指针位置无关。




参考
http://mysql.taobao.org/monthly/2015/09/01/
https://cloud.tencent.com/developer/article/1004516
https://dbaplus.cn/news-11-963-1.html


---------------------------------------------------------------------------------------------------------------------
MySQL索引的原理和数据结构能介绍一下吗？
b+树和b-树有什么区别？
MySQL聚簇索引和非聚簇索引的区别是什么？
他们分别是如何存储的？
使用MySQL索引都有哪些原则？
MySQL复合索引如何使用？



mysql的索引说白了就是用一个数据结构组织某一列的数据，然后如果你要根据那一列的数据查询的时候，就可以不用全表扫描，只要根据那个特定的数据结构去找到那一列的值，然后找到对应的行的物理地址即可。

数据结构B+树：B-树和B+树的数据结构是怎么样的的，为什么使用这个作为索引，有什么区别？


innodb存储引擎，要求必须有主键，会根据主键建立一个默认索引，叫做聚簇索引，innodb的数据文件本身同时也是个索引文件，索引存储结构大致如下：
就是因为这个原因，innodb表是要求必须有主键的，但是myisam表不要求必须有主键。
另外一个是，innodb存储引擎下，如果对某个非主键的字段创建个索引，那么最后那个叶子节点的值就是主键的值，因为可以用主键的值到聚簇索引里根据主键值再次查找到数据，即所谓的回表，例如：
select * from table where name = ‘张三’ 
先到name的索引里去找，找到张三对应的叶子节点，叶子节点的data就是那一行的主键，id=15，然后再根据id=15，到数据文件里面的聚簇索引（根据主键组织的索引）根据id=15去定位出来id=15这一行的完整的数据

所以这里就明白了一个道理，为啥innodb下不要用UUID生成的超长字符串作为主键？因为这么玩儿会导致所有的索引的data都是那个主键值，最终导致索引会变得过大，浪费很多磁盘空间。


myisam最大的特点是数据文件和索引文件是分开的，大家看到了么，先是索引文件里搜索，然后到数据文件里定位一个行的。
innodb存储引擎的索引实现，跟myisam最大的区别在于说，innodb的数据文件本身就是个索引文件，就是主键key，然后叶子节点的data就是那个数据的所在行。



MySQL复合索引如何使用

聚簇索引：主键索引，innodb存储引擎，要求必须有主键，会根据主键建立一个默认索引，叫做聚簇索引，所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据
联合索引（复合索引）
覆盖索引：查询的数据都是索引字段，覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。
    覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。


使用MySQL索引的使用规则

最左匹配原则：

当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。
联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。

反例：索引失效，不满足最左匹配原则
select userId，name from user where userId like '%123';

正例：满足最左匹配原则
select userId，name from user where userId like '123%';


索引的建立的原则有哪些
在哪些字段上建立索引：

为了在查询和排序，分组时去使用，也就是where，order by ，group by三个地方。
索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。
1. 最左前缀原理
2. 选择区分度高的列作为索引
3. 更新非常频繁的字段不适合创建索引
4. 尽量的扩展索引，不要新建索引
除了运用最左前缀、索引下推、考虑索引长度，还有哪些是建立索引需要考虑的 「这个实在想不到了」

尽管索引的目的在于提高数据库的性能，以下几种情况应该避免使用。以下准则显示，当使用索引应该重新考虑： 
1、索引不应该用在小型表上。 
2、有频繁的，大批量更新或插入操作的表。 
3、索引不应该用于对包含大量NULL值的列。 
4、列经常操纵不应该被索引。



索引失效的情况：参考【什么样的sql不走索引】
1、在索引列上使用mysql的内置函数
2、Like不符合最左匹配
3、=条件不符合最左匹配
4、where子句中使用or来连接条件
5、where 子句中对字段进行表达式操作
6、where 子句中使用!=或<>操作符
7、使用联合索引时，不遵循最左匹配原则。
8、如何字段类型是字符串，where时一定用引号括起来，否则索引失效



索引的缺点以及使用注意：
索引是有缺点的，比如常见的就是会增加磁盘消耗，因为要占用磁盘文件，同时高并发的时候频繁插入和修改索引，会导致性能损耗的。
我们给的建议，尽量创建少的索引，比如说一个表一两个索引，两三个索引，十来个，20个索引，高并发场景下还可以。




https://segmentfault.com/a/1190000014906118
https://database.51cto.com/art/202002/610953.htm
https://juejin.im/post/5e624d156fb9a07ca80ab6f2#heading-5
https://blog.csdn.net/Su_Xingyu/article/details/79900290



---------------------------------------------------------------------------------------------------------------------  


1、索引原理
2、索引分类（Index Class）
3、索引操作
4、索引使用策略
5、总结



## 1、索引原理
通过使用索引技术，MySQL 可以大大减少存储引擎需要扫描的数据量，把磁盘 IO 的随机读取变成顺序读取，从而加快查询效率。


## 2、索引分类（Index Class）
1. 主键（PRIMARY KEY）
2. 普通索引（INDEX）
3. 唯一索引（Unique）
4. 全文索引（FULLTEXT）
5. 空间索引（SPATIAL）



索引数据结构类型（Index Type）
MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。
MyISAM 的索引方式也叫做“非聚集”的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。

虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。

第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。
第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。


所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据
联合索引的最左前缀匹配原则

为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？
因为聚簇索引是将索引和数据都存放在叶子节点中，如果所有的索引都用聚簇索引，则每一个索引都将保存一份数据，会造成数据的冗余，在数据量很大的情况下，这种数据冗余是很消耗资源的。

覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。



3、索引操作

查看
MySQL 索引查询语法如下：
SHOW INDEX FROM table_name;

创建
MySQL 创建索引语法如下：
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name。。。

删除
MySQL 删除索引语法如下：
DROP INDEX index_name ON table_name;
或：
ALTER TABLE table_name DROP INDEX index_name;


4、索引使用策略

为了在查询和排序，分组时去使用，也就是where，order by ，group by三个地方。
索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。
1. 最左前缀原理
2. 选择区分度高的列作为索引
3. 更新非常频繁的字段不适合创建索引
4. 尽量的扩展索引，不要新建索引



5、总结
现在我们知道索引能够极大地提高数据检索效率，大大减少存储引擎需要扫描的数据量，把磁盘 IO 的随机读取变成顺序读取。
但是，索引并不是越多越好的，创建索引需要遵循一定的原则，否则会增加 MySQL 写操作的成本和查询优化器的选择时间，反而降低 MySQL 的性能。


https://cloud.tencent.com/developer/article/1558602


---------------------------------------------------------------------------------------------------------------------  

## 索引条件下推优化

索引条件下推优化（Index Condition Pushdown (ICP) ）
索引下推优化
适用条件
工作过程
不使用索引条件下推优化时的查询过程
使用索引条件下推优化时的查询过程
EXPLAN分析
配置




索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。
不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。
当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。
索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。


网上搜了下相关的文章不少都将Index Condition Pushdown 称为索引下推优化，我认为还是索引条件下推优化更合适一些，因为这个优化技术关键的操作就是将与索引相关的条件由MySQL服务器向下传递至存储引擎，由此减少IO次数。MySQL服务器到存储引擎是向下，传递的是与索引列相关的查询条件，所以还是索引条件下推优化更容易理解一些。

索引下推优化技术其实就是充分利用了索引中的数据，尽量在查询出整行数据之前过滤掉无效的数据。由于需要存储引擎将索引中的数据与条件进行判断，所以这个技术是基于存储引擎的，只有特定引擎可以使用。并且判断条件需要是在存储引擎这个层面可以进行的操作才可以，比如调用存储过程的条件就不可以，因为存储引擎没有调用存储过程的能力。



适用条件
1、需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。
2、适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。


不适用：
1、对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。
2、引用子查询的条件不能下推。
3、调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。
4、触发条件不能下推。



工作过程
既然是优化，我们要清楚优化了些什么就要了解原本是如何工作的，所以分为两部分来描述工作过程。

不使用索引条件下推优化时的查询过程
获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。然后通过where条件判断当前数据是否符合条件，符合返回数据。

使用索引条件下推优化时的查询过程
获取下一行的索引信息。
检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。
用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。

EXPLAN分析
当使用explan进行分析时，如果使用了索引条件下推，Extra会显示Using index condition。并不是Using index因为并不能确定利用索引条件下推查询出的数据就是符合要求的数据，还需要通过其他的查询条件来判断。


配置
索引下推优化是默认开启的。可以通过下面的脚本控制开关SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';



[什么是索引下推](https://juejin.im/post/5deef343e51d455819022033)




---------------------------------------------------------------------------------------------------------------------  





