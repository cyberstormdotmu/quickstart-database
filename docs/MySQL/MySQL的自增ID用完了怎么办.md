
MySQL 里有很多自增的 id，每个自增 id 都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型 (unsigned int) 是 4 个字节，上限就是 2^32-1

既然自增 id 有上限，就有可能被用完。但是，自增 id 用完了会怎么样呢？

表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。




首先我们一般创建 MySQL 数据表的时候，大部分情况下会创建一个自增主键ID 的字段，可能你的建表语句如下：
```
CREATE TABLE IF NOT EXISTS `tb`(
   `id` INT UNSIGNED AUTO_INCREMENT,
   `title` VARCHAR(100) NOT NULL,
   `body` VARCHAR(100) NOT NULL,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

```
我们可以算下最大当前声明的自增ID最大是多少，由于这里定义的是intunsigned，所以最大可以达到2的32幂次方 - 1 = 4294967295





可以看到 INT 类型的取值范围是 -2147483648 - 4294967295。所以 在 MySQL 中 自增 ID 是会用完的。那么问题来了，假如他的 ID 用完会发生什么事呢？


可以发现，AUTO_INCREMENT已经变成4294967295了，当想再尝试插入一条数据时，得到了下面的异常结果：

```
17:28:03 insert into t1 values(null) Error Code: 1062. Duplicate entry '4294967295' for key 'PRIMARY' 0.00054 sec
```
说明，当再次插入时，使用的自增ID还是4294967295，报主键冲突的错误。

可以看到，第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误。


2^32-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此在建表的时候你需要考察你的表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。

4294967295，这个数字已经可以应付大部分的场景了，如果你的服务会经常性的插入和删除数据的话，还是存在用完的风险，建议采用bigint unsigned，这个数字就大了。

所以在以后的建表过程中要衡量你的业务会不会超出这个量级。如果会那么久需要创建 8 字节的 INT 类型了，他的值最大是 2^64-1



那么问题又来了，你说 我有些业务是不需要主键 、不需要自增编号，我不创建这个字段，就好了，这样想恭喜你 回答错误.

如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。

实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：
- 1、row_id 写入表中的值范围，是从 0 到 2^48-1
- 2、当 dict_sys.row_id=2^48时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。 也就是说，写入表的 row_id 是从 0 开始到 2^48-1。达到上限后，下一个值就是 0，然后继续循环。

当然，2^48-1 这个值本身已经很大了，但是如果一个 MySQL 实例跑得足够久的话，还是可能达到这个上限的。在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。


不过，还存在另一种情况，如果在创建表没有显示申明主键，会怎么办？

如果是这种情况，InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id，而且InnoDB 维护了一个全局的 dictsys.row_id，所以未定义主键的表都共享该row_id，每次插入一条数据，都把全局row_id当成主键id，然后全局row_id加1

该全局row_id在代码实现上使用的是bigint unsigned类型，但实际上只给row_id留了6字节，这种设计就会存在一个问题：如果全局row_id一直涨，一直涨，直到2的48幂次-1时，这个时候再+1，row_id的低48位都为0，结果在插入新一行数据时，拿到的row_id就为0，存在主键冲突的可能性。

所以，为了避免这种隐患，每个表都需要定一个主键。




MySQL InnoDB系统自增row_id用完了怎么办

如果我们创建的表没有指定主键，那MySQL会给我们指定一个row_id作为主键。InnoDB维护了一个全局的dict_sys.row_id值，所有没有主键的InnoDB表，在每次插入一行数据时，都会将当前的dict_sys.row_id值作为要插入数据的row_id，然后dict_sys.row_id的值加1。

row_id占用6个字节长度，所以row_id也是有范围的，即row_id值的范围是从0到2^48(无符号)。

和MySQL自增id不同的是，如果row_id达到了上限，下一次取值就从0开始，然后继续循环。如果插入一条数据时申请到的row_id比如是0，如果表中没有row_id为0的数据则直接将数据插入到表中，但如果表中已经有row_id为0的数据，再插入时就会覆盖掉原来的数据。





总结： 
- 自增主键ID默认的无符号整型 (unsigned int)是4个字节，上限就是 2^32-1
- 表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变。
- 自增ID用完 会报主键冲突、数据插入失败。
- 因此在建表的时候你需要考察你的表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。他的值最大是 2^64-1

- 如果你创建的InnoDB表没有指定主键、默认创建的row_id会覆盖原有的数据。 
- row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度
- 当然，2^48-1 这个值本身已经很大了，但是如果一个 MySQL 实例跑得足够久的话，还是可能达到这个上限的。
- 在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。
- 和MySQL自增id不同的是，如果row_id达到了上限，下一次取值就从0开始，然后继续循环。如果插入一条数据时申请到的row_id比如是0，如果表中没有row_id为0的数据则直接将数据插入到表中，但如果表中已经有row_id为0的数据，再插入时就会覆盖掉原来的数据。
- 所以，为了避免这种隐患，每个表都需要定一个主键。



参考  
[MySQL 主键 自增 ID 会用完吗？](https://cloud.tencent.com/developer/article/1555286)  
[MySQL的自增ID用完了，怎么办](https://zhuanlan.zhihu.com/p/101979640)  
[MySQL自增id用完怎么办](https://blog.csdn.net/weixin_34220623/article/details/93183438)  
[InnoDB中的row_id与自增键用完怎么办](https://www.yisu.com/zixun/89824.html)  
[MySQL表自增id用完了该怎么办？](https://segmentfault.com/a/1190000023810042)